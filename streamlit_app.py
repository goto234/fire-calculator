"""
🔥  FIRE Calculator – Monte-Carlo (India Edition)
Clean, tool-tipped, glossary-driven, session-safe version
"""

from __future__ import annotations
import io, base64
from datetime import datetime
import numpy as np
import matplotlib.pyplot as plt
import streamlit as st

# ---------- APP-LEVEL STYLE ---------- #
plt.rcParams.update({
    "axes.facecolor":  "#f9f9f9",
    "figure.facecolor":"#ffffff",
    "axes.grid":       True,
    "grid.color":      "#d8d8d8",
    "font.size":       10,
    "axes.titlesize":  14,
    "axes.titleweight":"bold",
})

# ----- MOCK BACKEND (replace with real functions) ----- #
def simulate_fire(**kwargs):
    """Return a dict mimicking a Monte-Carlo engine output."""
    n    = kwargs["n_simulations"]
    yrs  = kwargs["total_years"] * 12
    rng  = np.random.default_rng(0)
    rets = rng.normal(0.005, 0.04, size=(n, yrs))  # dummy real returns
    corpus = kwargs["initial_corpus"] * (1 + rets).cumprod(axis=1)
    at_ret  = corpus[:, (kwargs["retirement_age"]-kwargs["current_age"])*12]
    out = {
        "corpus_matrix": corpus,
        "final_corpus_distribution": corpus[:, -1],
        "final_at_retirement": at_ret,
        "success_rate": np.mean(corpus[:, -1] > 0),
    }
    return out
# ------------------------------------------------------ #

# ---------- HELPERS ---------- #
def format_inr(val):
    if val >= 1e7: return f"₹{val/1e7:.2f} Cr"
    if val >= 1e5: return f"₹{val/1e5:.2f} L"
    return f"₹{val:,.0f}"

def fig_to_b64(fig):
    buf = io.BytesIO()
    fig.savefig(buf, format="png", bbox_inches="tight", dpi=160)
    plt.close(fig)
    return base64.b64encode(buf.getvalue()).decode()

def build_html_report(r:dict, version="1.0"):
    css = """
    body{font-family:Arial;background:#fefefe;color:#111;}
    h2{color:#2c3e50;border-bottom:1px solid #ccc;padding-bottom:4px;}
    table{border-collapse:separate;border-spacing:0;border:1px solid #ccc;border-radius:6px;overflow:hidden;margin-bottom:18px;width:100%;}
    th,td{padding:8px 12px;border:1px solid #ddd;}
    th{background:#e8f4ff;}
    img{max-width:100%;margin:10px 0;}
    """
    html = f"""<!DOCTYPE html><html><head><meta charset="UTF-8"><style>{css}</style></head><body>
<h1>🔥 FIRE Simulation Report</h1>
{r['inputs_html']}
{r['stats_html']}
{r['glossary_html']}
<h2>📊 Charts</h2>
<h4>Simulated Corpus Paths</h4><img src="data:image/png;base64,{r['fig1']}" alt="Corpus Paths">
<h4>Burn Curve (P10/P50/P90)</h4><img src="data:image/png;base64,{r['fig2']}" alt="Burn Curve">
<h4>Final Corpus Histogram</h4><img src="data:image/png;base64,{r['fig3']}" alt="Histogram">
<hr><p style="font-size:11px">Generated by FIRE Calculator v{version} — © 2025 Nishant Chadha<br>
Created on {datetime.now():%d %b %Y %H:%M}</p></body></html>"""
    return html

# ---------- STREAMLIT CONFIG ---------- #
st.set_page_config("🔥 FIRE Monte-Carlo", layout="centered")
st.title("🔥 FIRE Calculator – Monte-Carlo Simulation (India Edition)")

# ---------- EXPANDED HOW-TO ---------- #
with st.expander("📘 How does this work?"):
    st.markdown("""
1. **Choose inputs** on the sidebar. Hover 🛈 icons to see what each control does.  
2. **Quick Preview** runs **2 000 paths** (fast). **Full Simulation** runs your chosen path count (slower, higher accuracy).  
3. After a run you’ll get:  
   - **P10 / P50 / P90** corpus outcomes (worst ↔ best cases)  
   - **Success Rate** (never broke) & **Goal-Hit Rate** (hit target at retirement)  
   - **Burn Curve** visualising sequence-risk.  
4. **Download** a fully-formatted HTML report (offline-ready, charts embedded).  
""")


# ---------- SIDEBAR INPUT UI ---------- #
sb = st.sidebar
sb.header("📥 Simulation Inputs")

with sb.expander("🪙 Finances"):
    corpus0  = sb.number_input("Initial Corpus (₹)", 0., 1e9, 2e7,
                help="Money you already have invested for retirement, in today's rupees.")
    sip      = sb.number_input("Monthly SIP (₹)", 0., 1e7, 30000.,
                help="How much you’ll invest every month until retirement.")
    expense0 = sb.number_input("Monthly Expense (₹)", 0., 1e7, 50000.,
                help="First-month expense after retirement, real terms.")
    infl_pct = sb.slider("Expense Inflation % (real)", 0., 15., 6.,
                help="Annual real increase of expenses.") / 100

with sb.expander("👤 Lifestyle & Horizon"):
    age_now  = sb.number_input("Current Age", 18, 90, 35,
                help="Your age today.")
    age_ret  = sb.number_input("Retirement Age", age_now+1, 100, 45,
                help="When contributions stop & withdrawals start.")
    draw_years = sb.slider("Years After Retirement", 5, 60, 40,
                help="How long to simulate withdrawals.")

with sb.expander("📈 Portfolio"):
    eq_start = sb.slider("Starting Equity %", 0, 100, 70,
               help="Equity allocation during accumulation.") / 100
    glide_on = sb.checkbox("Use Glide Path", False,
               help="Equity % shifts linearly to 'Ending Equity %' by retirement.")
    eq_end   = sb.slider("Ending Equity %", 0, 100, 30,
               help="Equity % at retirement year." if glide_on else
                    "Ignored because Glide Path is OFF.") / 100
    dampen   = sb.checkbox("Dampen Returns After Retirement", False,
               help="Multiply post-retirement returns by 0.8 (conservative).")

with sb.expander("⚙️ Simulation Engine"):
    paths = sb.slider("Number of Monte-Carlo Paths", 1000, 20000, 10000,
             help="More paths = smoother percentiles, slower run.")
    goal  = sb.number_input("Target Corpus at Retirement (₹)", 0., 1e9, 3e7,
             help="Goal corpus (real ₹) to meet or exceed at retirement.")
    include_acc = sb.checkbox(
    "Include Accumulation Phase (SIPs)",
    value=True,
    help=(
        "ON → the simulator adds your Monthly SIP every month until retirement. "
        "OFF → it assumes you stop contributing today and only existing corpus grows."
    )
)


    
# ---------- SESSION STATE ---------- #
if "results" not in st.session_state: st.session_state.results = None

# ---------- TRIGGER BUTTONS ---------- #
colA, colB = st.columns(2)
run_quick  = colA.button("⚡ Quick Preview (2 000 paths)")
run_full   = colB.button("🧠 Full Simulation")

if run_quick or run_full:
    n_paths = 2000 if run_quick else paths
    status_placeholder = st.empty()
    status_placeholder.info(f"Running {n_paths:,} paths… please wait ⏳")
    
    
    # Optional: brief delay to simulate computation
    # import time; time.sleep(1.5)

    # Clear the message after simulation is complete
    status_placeholder.empty()


    result = simulate_fire(
        initial_corpus=corpus0,
        monthly_contribution=sip,     # ignored in mock
        monthly_expense=expense0,     # ignored in mock
        equity_weight=eq_start,
        n_simulations=n_paths,
        include_accumulation=include_acc,
        current_age=age_now,
        retirement_age=age_ret,
        total_years=draw_years,
        monthly_expense_growth=infl_pct,
        retirement_goal=goal,
        equity_glide_end=eq_end if glide_on else None,
        dampen_post_ret=0.8 if dampen else 1.0,
        start="2000-01-01"
    )

    corpus_mat  = result["corpus_matrix"]
    final_dist  = result["final_corpus_distribution"]
    at_ret_dist = result["final_at_retirement"]

    success_rate = result["success_rate"]
    goal_hit     = np.mean(at_ret_dist >= goal)
    p10, p50, p90 = np.percentile(final_dist, [10,50,90])
    failures      = (final_dist <= 0).sum()
    years         = np.arange(corpus_mat.shape[1]) / 12

    # ---------- CHARTS ---------- #
    # paths fan
    fig1, ax1 = plt.subplots(figsize=(9,4))
    ax1.plot(years, corpus_mat[:300].T, alpha=0.04, color=plt.cm.Set2(0))
    ax1.set_title("Corpus Paths (sample of 300)")
    ax1.set_xlabel("Years"); ax1.set_ylabel("Corpus (₹)")
    # burn curve
    fig2, ax2 = plt.subplots(figsize=(9,4))
    cols = plt.cm.Set2([0,1,2])
    ax2.plot(years, np.percentile(corpus_mat,50,axis=0), label="P50", color=cols[0])
    ax2.plot(years, np.percentile(corpus_mat,10,axis=0), label="P10", color=cols[1], linestyle="--")
    ax2.plot(years, np.percentile(corpus_mat,90,axis=0), label="P90", color=cols[2], linestyle="--")
    ax2.legend(loc="upper left", bbox_to_anchor=(1.02,1))
    ax2.set_title("Burn Curve (P10 / P50 / P90)")
    ax2.set_xlabel("Years"); ax2.set_ylabel("Corpus (₹)")
    # histogram
    fig3, ax3 = plt.subplots(figsize=(7,4))
    ax3.hist(final_dist/1e6, bins=40, color="#00897b", alpha=0.85,
             edgecolor="white", linewidth=0.8)
    ax3.set_title("Final Corpus Distribution (₹ Cr)")
    ax3.set_xlabel("Corpus at End"); ax3.set_ylabel("Simulations")

    # ---------- BUILD HTML STRINGS ---------- #
    inputs_tab = f"""
<h2>User Inputs</h2><table>
<tr><th>Parameter</th><th>Value</th></tr>
<tr><td>Age (now/ret)</td><td>{age_now} → {age_ret}</td></tr>
<tr><td>Initial Corpus</td><td>{format_inr(corpus0)}</td></tr>
<tr><td>Monthly SIP</td><td>{format_inr(sip)}</td></tr>
<tr><td>Expense (first mth)</td><td>{format_inr(expense0)}</td></tr>
<tr><td>Inflation</td><td>{infl_pct*100:.1f}%</td></tr>
<tr><td>Equity %</td><td>{eq_start*100:.0f}% {'→ '+str(int(eq_end*100))+'%' if glide_on else ''}</td></tr>
<tr><td>Paths</td><td>{n_paths:,}</td></tr>
<tr><td>Target Corpus</td><td>{format_inr(goal)}</td></tr>
</table>"""

    stats_tab = f"""
<h2>Simulation Results</h2><table>
<tr><td>Success Rate</td><td>{success_rate*100:.2f}%</td></tr>
<tr><td>Goal Hit Rate</td><td>{goal_hit*100:.2f}%</td></tr>
<tr><td>Ruined Runs</td><td>{failures} / {n_paths:,}</td></tr>
<tr><td>P10 Corpus</td><td>{format_inr(p10)}</td></tr>
<tr><td>Median (P50)</td><td>{format_inr(p50)}</td></tr>
<tr><td>P90 Corpus</td><td>{format_inr(p90)}</td></tr>
</table>"""

    glossary = """
<h2>📘 Glossary</h2>
<ul>
<li><b>P10</b> – Worst 10 % of outcomes.</li>
<li><b>P50</b> – Median outcome.</li>
<li><b>P90</b> – Best 10 % of outcomes.</li>
<li><b>Success Rate</b> – Corpus never hit ₹0.</li>
<li><b>Goal-Hit Rate</b> – Corpus at retirement ≥ target.</li>
<li><b>Ruined Run</b> – Corpus depleted before final year.</li>
</ul>"""

    st.session_state.results = dict(
        fig1=fig_to_b64(fig1), fig2=fig_to_b64(fig2), fig3=fig_to_b64(fig3),
        inputs_html=inputs_tab, stats_html=stats_tab, glossary_html=glossary)

# ---------- SHOW RESULTS IF AVAILABLE ---------- #
if st.session_state.results:
    r = st.session_state.results

    st.info("ℹ️ **Definitions:** P10=Pessimistic, P50=Median, P90=Optimistic. "
            "Hover chart titles for more tips.")

    col1, col2, col3 = st.columns(3)
    col1.metric("✅ Success", r['stats_html'].split('<td>')[3].split('</td>')[0])
    col2.metric("🎯 Goal Hit", r['stats_html'].split('<td>')[5].split('</td>')[0])
    col3.metric("📉 Ruined", r['stats_html'].split('<td>')[7].split('</td>')[0])

    st.image("data:image/png;base64," + r["fig1"], caption="💸 Simulated Corpus Paths")
    st.image("data:image/png;base64," + r["fig2"], caption="📉 Burn Curve (P10/P50/P90)")
    st.image("data:image/png;base64," + r["fig3"], caption="📊 Final Corpus Histogram")

    if st.button("📄 Generate HTML Report"):
        html = build_html_report(r)
        st.download_button("📥 Download Report", data=html.encode(),
                           file_name="FIRE_Report.html", mime="text/html")
        st.caption("Open in browser → Ctrl+P to save as PDF.")

